import { ESLint } from "eslint";
import path from 'path';
import fs from 'fs-extra';
import ConsoleWriter from "./ConsoleWriter.js";
import { getRootPath } from "./utils.js";
export class LintValidator {
    visualPath;
    rootPath;
    isVerboseMode;
    useDefault;
    shouldFix;
    config;
    linterInstance;
    constructor({ verbose, fix, useDefault }) {
        this.visualPath = process.cwd();
        this.rootPath = getRootPath();
        this.isVerboseMode = verbose;
        this.useDefault = useDefault;
        this.shouldFix = fix;
        this.prepareConfig();
        this.linterInstance = new ESLint(this.config);
    }
    /**
     * Runs lint validation in the visual folder
     */
    async runLintValidation() {
        ConsoleWriter.info("Running lint check...");
        // By default it will lint all files in the src of current working directory, but some files can be excluded in .eslintignore
        const results = await this.linterInstance.lintFiles("src/");
        if (this.shouldFix) {
            await this.fixErrors(results);
        }
        await this.outputResults(results);
        ConsoleWriter.info("Lint check completed.");
    }
    async fixErrors(results) {
        ConsoleWriter.info("Lint fixing errors...");
        await ESLint.outputFixes(results);
    }
    async outputResults(results) {
        if (this.isVerboseMode) {
            const formatter = await this.linterInstance.loadFormatter("stylish");
            const formattedResults = await formatter.format(results);
            console.log(formattedResults);
        }
        else {
            const filteredResults = ESLint.getErrorResults(results);
            // get total amount of errors and warnings in all elements of filteredResults
            const totalErrors = filteredResults.reduce((acc, curr) => acc + curr.errorCount, 0);
            const totalWarnings = filteredResults.reduce((acc, curr) => acc + curr.warningCount, 0);
            if (totalErrors > 0 || totalWarnings > 0) {
                ConsoleWriter.error(`Linter found ${totalErrors} errors and ${totalWarnings} warnings. Run with --verbose flag to see details.`);
            }
        }
    }
    prepareConfig() {
        const requiredConfig = {
            extensions: [".js", ".jsx", ".ts", ".tsx"],
            fix: this.shouldFix,
            resolvePluginsRelativeTo: this.getPluginPath()
        };
        const eslintrcExtensions = ['.json', '.js', '.cjs', '.ts', ''];
        if (!this.useDefault && eslintrcExtensions.some(el => fs.existsSync(path.join(this.visualPath, `.eslintrc${el}`)))) {
            this.config = requiredConfig;
        }
        else {
            ConsoleWriter.warning("Using recommended eslint config.");
            this.config = {
                ...requiredConfig,
                overrideConfig: {
                    env: {
                        browser: true,
                        es6: true,
                        es2022: true
                    },
                    plugins: [
                        "powerbi-visuals"
                    ],
                    extends: [
                        "plugin:powerbi-visuals/recommended"
                    ]
                },
                useEslintrc: false,
            };
        }
    }
    getPluginPath() {
        const pluginPaths = [
            path.resolve(this.visualPath, "node_modules", "eslint-plugin-powerbi-visuals"),
            path.resolve(this.rootPath, "node_modules", "eslint-plugin-powerbi-visuals")
        ];
        return pluginPaths.find(fs.existsSync);
    }
}
