import { DisplayUnitSystem, DisplayUnitSystemNames } from "./displayUnitSystem/displayUnitSystem";
import { DisplayUnitSystemType } from "./displayUnitSystem/displayUnitSystemType";
import { DisplayUnit } from "./displayUnitSystem/displayUnitSystem";
import { numberFormat as NumberFormat } from "./formattingService/formattingService";
import powerbi from "powerbi-visuals-api";
import DataViewMetadataColumn = powerbi.DataViewMetadataColumn;
import DataViewObjectPropertyIdentifier = powerbi.DataViewObjectPropertyIdentifier;
import ValueTypeDescriptor = powerbi.ValueTypeDescriptor;
/**
 * Formats the value using provided format expression
 * @param value - value to be formatted and converted to string.
 * @param format - format to be applied if the number shouldn't be abbreviated.
 * If the number should be abbreviated this string is checked for special characters like $ or % if any
 */
export interface ICustomValueFormatter {
    (value: any, format?: string): string;
}
export interface ICustomValueColumnFormatter {
    (value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier, nullsAreBlank?: boolean): string;
}
export interface ValueFormatterOptions {
    format?: string;
    value?: any;
    value2?: any;
    tickCount?: any;
    displayUnitSystemType?: DisplayUnitSystemType;
    formatSingleValues?: boolean;
    allowFormatBeautification?: boolean;
    precision?: number;
    detectAxisPrecision?: boolean;
    columnType?: ValueTypeDescriptor;
    cultureSelector?: string;
}
export interface IValueFormatter {
    format(value: any): string;
    displayUnit?: DisplayUnit;
    options?: ValueFormatterOptions;
}
export interface ValueFormatterLocalizationOptions {
    nullValue: string;
    trueValue: string;
    falseValue: string;
    NaN: string;
    infinity: string;
    negativeInfinity: string;
    beautify(format: string): string;
    describe(exponent: number): DisplayUnitSystemNames;
    restatementComma: string;
    restatementCompoundAnd: string;
    restatementCompoundOr: string;
}
export declare const DefaultIntegerFormat = "g";
export declare const DefaultNumericFormat = "#,0.00";
export declare const DefaultDateFormat = "d";
export declare function getLocalizedString(stringId: string): string;
export declare function getFormatMetadata(format: string): NumberFormat.NumericFormatMetadata;
export declare function setLocaleOptions(options: ValueFormatterLocalizationOptions): void;
export declare function createDefaultFormatter(formatString: string, allowFormatBeautification?: boolean, cultureSelector?: string): IValueFormatter;
/**
 * Check that provided value is in provided bounds. If not -- replace it by minimal or maximal replacement value
 * @param targetNum checking value
 * @param min minimal bound of value
 * @param max maximal bound of value
 * @param lessMinReplacement value that will be returned if checking value is lesser than minimal
 * @param greaterMaxReplacement value that will be returned if checking value is greater than maximal
 */
export declare function checkValueInBounds(targetNum: number, min: number, max: number, lessMinReplacement?: number, greaterMaxReplacement?: number): number;
export declare function create(options: ValueFormatterOptions): IValueFormatter;
export declare function format(value: any, format?: string, allowFormatBeautification?: boolean, cultureSelector?: string): string;
/**
 * Value formatting function to handle variant measures.
 * For a Date/Time value within a non-date/time field, it's formatted with the default date/time formatString instead of as a number
 * @param {any} value Value to be formatted
 * @param {DataViewMetadataColumn} column Field which the value belongs to
 * @param {DataViewObjectPropertyIdentifier} formatStringProp formatString Property ID
 * @param {boolean} nullsAreBlank? Whether to show "(Blank)" instead of empty string for null values
 * @returns Formatted value
 */
export declare function formatVariantMeasureValue(value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier, nullsAreBlank?: boolean, cultureSelector?: string): string;
export declare function createDisplayUnitSystem(displayUnitSystemType?: DisplayUnitSystemType): DisplayUnitSystem;
export declare function getFormatString(column: DataViewMetadataColumn, formatStringProperty: DataViewObjectPropertyIdentifier, suppressTypeFallback?: boolean): string;
export declare function getFormatStringByColumn(column: DataViewMetadataColumn, suppressTypeFallback?: boolean): string;
export declare function formatListAnd(strings: string[]): string;
export declare function formatListOr(strings: string[]): string;
export declare function getDisplayUnits(displayUnitSystemType: DisplayUnitSystemType): DisplayUnit[];
/**
 * Precision calculating function to build values showing minimum 3 digits as 3.56 or 25.7 or 754 or 2345
 * @param {number} inputValue Value to be basement for precision calculation
 * @param {string} format Format that will be used for value formatting (to detect percentage values)
 * @param {number} displayUnits Dispaly units that will be used for value formatting (to correctly calculate precision)
 * @param {number} digitsNum Number of visible digits, including digits before separator
 * @returns calculated precision
 */
export declare function calculateExactDigitsPrecision(inputValue: number, format: string, displayUnits: number, digitsNum: number): number;
